{
  "id": "shamshoo-aniwatch-provider",
  "name": "AniWatch",
  "description": "Online anime streaming provider",
  "version": "1.0.4",
  "type": "onlinestream-provider",
  "manifestURI": "https://raw.githubusercontent.com/Shamshoo/aniwatch/refs/heads/main/manifest.json",
  "language": "typescript",
  "author": "Shamshoo",
  "meta": {
    "website": "https://aniwatchtv.to"
  },
  "payload": "///<reference path=\"./onlinestream-provider.d.ts\"/>\n///<reference path=\"./doc.d.ts\"/>\n///<reference path=\"./crypto.d.ts\"/>\n\nclass Provider{\napi=\"https://aniwatchtv.to\"\n\ngetSettings():Settings{\nreturn{\nepisodeServers:[\"default\",\"vidstreaming\",\"streamsb\"],\nsupportsDub:true,\n}\n}\n\nasync search(opts:SearchOptions):Promise<SearchResult[]>{\ntry{\nconst request=await fetch(`${this.api}/search?keyword=${encodeURIComponent(opts.query)}`)\nif(!request.ok){\nreturn[]\n}\n\nconst html=await request.text()\nconst $=LoadDoc(html)\n\nconst results:SearchResult[]=[]\n\n$(\".flw-item\").each((_,el)=>{\nconst title=el.find(\".film-name a\").text().trim()\nconst href=el.find(\".film-name a\").attr(\"href\")\nconst dubElem=el.find(\".tick-dub\")\nconst subElem=el.find(\".tick-sub\")\n\nif(!href){\nreturn\n}\n\nlet subOrDub:SubOrDub=\"sub\"\nif(dubElem.length()>0&&subElem.length()>0){\nsubOrDub=\"both\"\n}else if(dubElem.length()>0){\nsubOrDub=\"dub\"\n}\n\nresults.push({\nid:href,\ntitle:title,\nurl:this.api+href,\nsubOrDub:subOrDub\n})\n})\n\nreturn results\n}catch(error){\nconsole.error(\"Search error:\",error)\nreturn[]\n}\n}\n\nasync findEpisodes(id:string):Promise<EpisodeDetails[]>{\ntry{\nif(!id.startsWith(\"/\")){\nid=\"/\"+id\n}\n\nconst url=`${this.api}${id}`\nconst response=await fetch(url)\n\nif(!response.ok){\nreturn[]\n}\n\nconst html=await response.text()\nconst $=LoadDoc(html)\n\nconst episodes:EpisodeDetails[]=[]\nconst animeId=$(\".favorites.add-favorite\").attr(\"data-id\")\n\nif(!animeId){\nreturn[]\n}\n\nconst totalEpisodes=parseInt($(\".detail-infor-content .spl-button\").text().split(\" \").pop()||\"0\",10)\n\nconst episodeListResp=await fetch(`${this.api}/ajax/v2/episode/list/${animeId}`)\nconst episodeListData=await episodeListResp.json()\n\nif(episodeListData.status){\nconst episodeListHtml=episodeListData.html\nconst $episodes=LoadDoc(episodeListHtml)\n\n$episodes(\".ep-item\").each((_,el)=>{\nconst episodeNumber=parseFloat(el.attr(\"data-number\")||\"0\")\nconst episodeId=el.attr(\"data-id\")\nconst href=el.attr(\"href\")\n\nif(href){\nepisodes.push({\nid:href,\nnumber:episodeNumber,\nurl:this.api+href,\ntitle:`Episode ${episodeNumber}`\n})\n}\n})\n}\n\nreturn episodes.sort((a,b)=>a.number-b.number)\n}catch(error){\nconsole.error(\"Find episodes error:\",error)\nreturn[]\n}\n}\n\nasync findEpisodeServer(episode:EpisodeDetails,_server:string):Promise<EpisodeServer>{\nlet server=\"default\"\nif(_server!==\"default\"){\nserver=_server\n}\n\nconst episodeServer:EpisodeServer={\nserver:server,\nheaders:{\n\"Referer\":this.api,\n\"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36\"\n},\nvideoSources:[]\n}\n\ntry{\nif(!episode.id.startsWith(\"/\")){\nepisode.id=\"/\"+episode.id\n}\n\nconst url=`${this.api}${episode.id}`\nconst response=await fetch(url)\n\nif(!response.ok){\nreturn episodeServer\n}\n\nconst html=await response.text()\nconst $=LoadDoc(html)\n\nconst episodeId=$(\".players-section\").attr(\"data-id\")||url.split(\"/\").pop()||\"\"\n\nlet serverId=\"\"\n\nswitch(server){\ncase\"vidstreaming\":\nserverId=$(`.servers-content .server-item[data-name*=\"vidstream\"]`).attr(\"data-id\")||\"\"\nbreak\ncase\"streamsb\":\nserverId=$(`.servers-content .server-item[data-name*=\"streamsb\"]`).attr(\"data-id\")||\"\"\nbreak\ndefault:\nserverId=$(`.servers-content .server-item`).first().attr(\"data-id\")||\"\"\nbreak\n}\n\nif(!serverId){\nreturn episodeServer\n}\n\nconst sourceUrl=`${this.api}/ajax/v2/episode/servers?episodeId=${episodeId}`\nconst sourceResp=await fetch(sourceUrl,{\nheaders:{\n\"X-Requested-With\":\"XMLHttpRequest\",\n\"Referer\":url\n}\n})\n\nconst sourceData=await sourceResp.json()\n\nif(sourceData.status){\nconst sourceHtml=sourceData.html\nconst $sources=LoadDoc(sourceHtml)\n\nconst serverEl=$sources(`.server-item[data-id=\"${serverId}\"]`)\n\nif(serverEl.length()>0){\nconst encryptUrl=`${this.api}/ajax/v2/episode/sources?id=${serverId}`\nconst encryptResp=await fetch(encryptUrl,{\nheaders:{\n\"X-Requested-With\":\"XMLHttpRequest\",\n\"Referer\":url\n}\n})\n\nconst encryptData=await encryptResp.json()\n\nif(encryptData.status&&encryptData.link){\nconst type:VideoSourceType=encryptData.link.includes(\".m3u8\")?\"m3u8\":\"mp4\"\n\nepisodeServer.videoSources.push({\nurl:encryptData.link,\nquality:\"auto\",\ntype:type,\nsubtitles:[]\n})\n\nif(type===\"m3u8\"&&!encryptData.link.includes(\"iframe\")){\ntry{\nconst m3u8Resp=await fetch(encryptData.link,{\nheaders:episodeServer.headers\n})\n\nif(m3u8Resp.ok){\nconst m3u8Text=await m3u8Resp.text()\nconst resolutionMatches=m3u8Text.match(/RESOLUTION=\\d+x(\\d+)/g)\n\nif(resolutionMatches){\nconst uniqueQualities=new Set<string>()\n\nresolutionMatches.forEach(res=>{\nconst quality=res.split(\"=\")[1].split(\"x\")[1]\nuniqueQualities.add(quality)\n})\n\nuniqueQualities.forEach(quality=>{\nepisodeServer.videoSources.push({\nurl:encryptData.link,\nquality:`${quality}p`,\ntype:\"m3u8\",\nsubtitles:[]\n})\n})\n}\n}\n}catch(error){\nconsole.error(\"Error fetching m3u8:\",error)\n}\n}\n}\n}\n}\n\nreturn episodeServer\n}catch(error){\nconsole.error(\"Find episode server error:\",error)\nreturn episodeServer\n}\n}\n}"
}
